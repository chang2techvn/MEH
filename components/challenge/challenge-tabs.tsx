"use client"

import { useState, useEffect, useCallback, useMemo } from "react"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import OptimizedChallengeGrid from "@/components/optimized/optimized-challenge-grid"
import CreateChallengeModal from "@/components/challenge/create-challenge-modal"
import { getChallenges } from "@/app/actions/youtube-video"
import { type Challenge } from '@/lib/utils/challenge-constants'
import { toast } from "@/hooks/use-toast"
import { useDebounce } from "@/hooks/use-performance"
import { useChallenge } from "@/contexts/challenge-context"

interface ChallengeTabsProps {
  searchTerm: string
  onSelectedChallengeChange: (challenge: Challenge | null) => void
}

export default function ChallengeTabs({
  searchTerm,
  onSelectedChallengeChange
}: ChallengeTabsProps) {  const [challenges, setChallenges] = useState<Challenge[]>([])
  const [userChallenges, setUserChallenges] = useState<Challenge[]>([])
  const [activeTab, setActiveTab] = useState("all")
  const [loading, setLoading] = useState(true)
  const [createModalOpen, setCreateModalOpen] = useState(false)
  const { setChallengeMode, setCurrentChallenge } = useChallenge()
  
  // Debounced search term using hook
  const debouncedSearchTerm = useDebounce(searchTerm, 300)

  // Debounced localStorage save function
  const saveToLocalStorage = useCallback((key: string, data: any) => {
    try {
      // Only save essential data to localStorage
      const essentialData = data.map((challenge: Challenge) => ({
        id: challenge.id,
        title: challenge.title,
        description: challenge.description,
        difficulty: challenge.difficulty,
        duration: challenge.duration,
        createdAt: challenge.createdAt,
        thumbnailUrl: challenge.thumbnailUrl,
        videoUrl: challenge.videoUrl,
        // Skip large fields like topics array if not essential
      }))
      localStorage.setItem(key, JSON.stringify(essentialData))
    } catch (error) {
      console.error('Error saving to localStorage:', error)
      // If localStorage is full, clear old data
      if (error instanceof Error && error.name === 'QuotaExceededError') {
        localStorage.removeItem('admin_challenges')
        localStorage.removeItem('lastChallengeRefresh')
        // Retry with smaller dataset
        try {
          localStorage.setItem(key, JSON.stringify(data.slice(0, 10)))
        } catch (retryError) {
          console.error('Failed to save even reduced data:', retryError)
        }
      }
    }
  }, [])

  // Load challenges when component mounts
  const loadChallenges = useCallback(async () => {
    try {
      // Set loading to false immediately to show skeleton content
      setLoading(false)

      // Load practice challenges and user challenges in parallel
      const [practiceData, userData] = await Promise.all([
        getChallenges('practice', { limit: 15 }), // Get latest 15 practice videos
        getChallenges('user_generated', { limit: 50 })
      ])

      // Convert to Challenge format if needed
      const practicesChallenges: Challenge[] = practiceData.map((challenge: any) => {
        // Extract video ID from video_url for YouTube player functionality
        let videoId = challenge.id // Default to challenge ID
        
        if (challenge.video_url) {
          // Try YouTube URL formats
          const youtubeMatch = challenge.video_url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/)
          if (youtubeMatch) {
            videoId = youtubeMatch[1]
          } else {
            // Fallback to simple extraction
            videoId = challenge.video_url.split('v=')[1]?.split('&')[0] || 
                     challenge.video_url.split('/').pop() || 
                     challenge.id
          }
        }

        console.log('üé¨ Practice Challenge mapping:', {
          databaseId: challenge.id,
          videoUrl: challenge.video_url,
          extractedVideoId: videoId,
          hasTranscript: !!challenge.transcript,
          transcriptLength: challenge.transcript?.length || 0
        })

        return {
          id: challenge.id, // Keep database ID as main ID for database operations
          databaseId: challenge.id, // Also store as databaseId for clarity
          videoId: videoId, // Store video ID separately for YouTube player
          title: challenge.title,
          description: challenge.description || '',
          difficulty: challenge.difficulty || 'intermediate',
          duration: challenge.duration || 0,
          thumbnailUrl: challenge.thumbnail_url || `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`,
          videoUrl: challenge.video_url || `https://www.youtube.com/watch?v=${videoId}`,
          embedUrl: challenge.embed_url || `https://www.youtube.com/embed/${videoId}`,
          topics: Array.isArray(challenge.topics) ? challenge.topics : [],
          isAutoGenerated: true,
          createdAt: challenge.created_at,
          transcript: challenge.transcript || ''
        }
      })

      const userCreatedChallenges: Challenge[] = userData.map((challenge: any) => {
        // Extract video ID from video_url for YouTube player functionality
        let videoId = challenge.id // Default to challenge ID
        
        if (challenge.video_url) {
          // Try YouTube URL formats
          const youtubeMatch = challenge.video_url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/)
          if (youtubeMatch) {
            videoId = youtubeMatch[1]
          } else {
            // Fallback to simple extraction
            videoId = challenge.video_url.split('v=')[1]?.split('&')[0] || 
                     challenge.video_url.split('/').pop() || 
                     challenge.id
          }
        }

        return {
          id: challenge.id, // Keep database ID as main ID for database operations
          databaseId: challenge.id, // Also store as databaseId for clarity
          videoId: videoId, // Store video ID separately for YouTube player
          title: challenge.title,
          description: challenge.description || '',
          difficulty: challenge.difficulty || 'intermediate',
          duration: challenge.duration || 0,
          thumbnailUrl: challenge.thumbnail_url || `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`,
          videoUrl: challenge.video_url || `https://www.youtube.com/watch?v=${videoId}`,
          embedUrl: challenge.embed_url || `https://www.youtube.com/embed/${videoId}`,
          topics: Array.isArray(challenge.topics) ? challenge.topics : [],
          isAutoGenerated: false,
          createdAt: challenge.created_at,
          transcript: challenge.transcript || ''
        }
      })

      // Check for local user challenges
      const savedChallenges = localStorage.getItem("userChallenges")
      let localUserChallenges: Challenge[] = []

      if (savedChallenges) {
        localUserChallenges = JSON.parse(savedChallenges)
      }

      // Combine all challenges
      const combinedChallenges = [
        ...practicesChallenges,      // Practice challenges first
        ...userCreatedChallenges,    // User challenges from database
        ...localUserChallenges       // Local user challenges
      ]
      
      // Set separate states
      setUserChallenges([...userCreatedChallenges, ...localUserChallenges])
      setChallenges(combinedChallenges)

    } catch (error: any) {
      console.error("Error loading challenges:", error)
      toast({
        title: "Error",
        description: "Failed to load challenges. Please try again.",
        variant: "destructive",
      })
      setLoading(false)
    }
  }, [])

  useEffect(() => {
    loadChallenges()
  }, [loadChallenges])
  // Filter challenges when tab or search term changes - optimized with useMemo
  const filteredChallenges = useMemo(() => {
    let filtered: Challenge[] = []

    // Determine which challenges to filter based on active tab
    if (activeTab === "user") {
      filtered = userChallenges
    } else if (activeTab === "all") {
      filtered = challenges
    } else {
      // Filter by difficulty (beginner, intermediate, advanced)
      filtered = challenges.filter((challenge) => challenge.difficulty === activeTab)
    }

    // Apply search filter only if debounced search term exists
    if (debouncedSearchTerm) {
      const lowerSearchTerm = debouncedSearchTerm.toLowerCase()
      filtered = filtered.filter(
        (challenge) =>
          challenge.title.toLowerCase().includes(lowerSearchTerm) ||
          challenge.description.toLowerCase().includes(lowerSearchTerm),
      )
    }
    
    return filtered
  }, [challenges, userChallenges, debouncedSearchTerm, activeTab])

  // Handle challenge creation - optimized
  const handleChallengeCreated = useCallback((newChallenge: Challenge) => {
    // Th√™m th·ª≠ th√°ch m·ªõi v√†o danh s√°ch user challenges
    const updatedUserChallenges = [newChallenge, ...userChallenges]
    const updatedAllChallenges = [newChallenge, ...challenges]
    
    setUserChallenges(updatedUserChallenges)
    setChallenges(updatedAllChallenges)    // Debounced localStorage save to avoid blocking UI
    saveToLocalStorage('userChallenges', updatedUserChallenges)

    // Hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng
    toast({
      title: "Challenge created",
      description: "Your challenge has been added to the list",
    })
    
    // Switch to user challenges tab to show the new challenge
    setActiveTab("user")
  }, [userChallenges, challenges, saveToLocalStorage])

  // Handle when user starts a challenge
  const handleStartChallenge = useCallback((id: string) => {
    // T√¨m challenge v·ªõi id t∆∞∆°ng ·ª©ng
    const challenge = challenges.find(c => c.id === id)
    
    if (challenge) {
      // Convert challenge to have proper format for unified challenges table
      const practiceChallenge: Challenge = {
        ...challenge,
        // Ensure it has proper video properties for the database lookup
        videoUrl: challenge.videoUrl || challenge.embedUrl || "",
        embedUrl: challenge.embedUrl || challenge.videoUrl || "",
      }
      
      // Set practice mode and challenge
      setChallengeMode('practice')
      setCurrentChallenge(practiceChallenge)
      
      // Set challenge ƒë∆∞·ª£c ch·ªçn ƒë·ªÉ hi·ªÉn th·ªã ·ªü "Your Current Challenge"
      onSelectedChallengeChange(practiceChallenge)
      
      toast({
        title: "Practice Challenge started",
        description: `Started: ${challenge.title}`,
      })
      
      // Scroll l√™n top ƒë·ªÉ user c√≥ th·ªÉ th·∫•y "Your Practice Challenge"
      window.scrollTo({ top: 0, behavior: 'smooth' })
    } else {
      console.error("‚ùå [ChallengeTabs] Challenge not found with ID:", id)
      toast({
        title: "Error",
        description: "Challenge not found",
        variant: "destructive",
      })
    }
  }, [challenges, onSelectedChallengeChange, setChallengeMode, setCurrentChallenge])

  return (
    <>      <Tabs defaultValue="all" value={activeTab} onValueChange={setActiveTab} className="w-full">
        <TabsList className="grid w-full grid-cols-5">
          <TabsTrigger value="all">All</TabsTrigger>
          <TabsTrigger value="user">Your Challenges</TabsTrigger>
          <TabsTrigger value="beginner">Beginner</TabsTrigger>
          <TabsTrigger value="intermediate">Intermediate</TabsTrigger>
          <TabsTrigger value="advanced">Advanced</TabsTrigger>
        </TabsList>        <TabsContent value="user" className="mt-6">
          <div className="mb-4">
            <h3 className="text-lg font-semibold text-foreground">Your Created Challenges</h3>
            <p className="text-sm text-muted-foreground">Challenges you've created ‚Ä¢ {userChallenges.length} available</p>
          </div>
          

          <OptimizedChallengeGrid
            challenges={userChallenges}
            onStartChallenge={handleStartChallenge}
            loading={loading}
            emptyMessage="You haven't created any challenges yet"
            emptyAction={() => setCreateModalOpen(true)}
            emptyActionLabel="Create Your First Challenge"
            useVirtualScroll={userChallenges.length > 20}
          />

        </TabsContent>          
        <TabsContent value="all" className="mt-6">
          <div className="mb-4">
            <h3 className="text-lg font-semibold text-foreground">All Challenges</h3>
            <p className="text-sm text-muted-foreground">Auto-generated + User challenges ‚Ä¢ {challenges.length} total</p>
          </div>
          

          <OptimizedChallengeGrid
            challenges={filteredChallenges}
            onStartChallenge={handleStartChallenge}
            loading={loading}
            emptyMessage="No challenges found matching your criteria"
            emptyAction={() => setCreateModalOpen(true)}
            emptyActionLabel="Create a Challenge"
            useVirtualScroll={filteredChallenges.length > 20}
            useInfiniteScroll={false}
          />

        </TabsContent>
          <TabsContent value="beginner" className="mt-6">
          <div className="mb-4">
            <h3 className="text-lg font-semibold text-foreground">Beginner Challenges</h3>
            <p className="text-sm text-muted-foreground">Perfect for starting your English journey ‚Ä¢ {filteredChallenges.length} available</p>
          </div>

          <OptimizedChallengeGrid
            challenges={filteredChallenges}
            onStartChallenge={handleStartChallenge}
            loading={loading}
            emptyMessage="No beginner challenges found"
            emptyAction={() => setCreateModalOpen(true)}
            emptyActionLabel="Create a Beginner Challenge"
            useVirtualScroll={filteredChallenges.length > 20}
          />

        </TabsContent>        
        <TabsContent value="intermediate" className="mt-6">
          <div className="mb-4">
            <h3 className="text-lg font-semibold text-foreground">Intermediate Challenges</h3>
            <p className="text-sm text-muted-foreground">Level up your skills ‚Ä¢ {filteredChallenges.length} available</p>
          </div>

          <OptimizedChallengeGrid
            challenges={filteredChallenges}
            onStartChallenge={handleStartChallenge}
            loading={loading}
            emptyMessage="No intermediate challenges found"
            emptyAction={() => setCreateModalOpen(true)}
            emptyActionLabel="Create an Intermediate Challenge"
            useVirtualScroll={filteredChallenges.length > 20}
          />

        </TabsContent>
          <TabsContent value="advanced" className="mt-6">
          <div className="mb-4">
            <h3 className="text-lg font-semibold text-foreground">Advanced Challenges</h3>
            <p className="text-sm text-muted-foreground">Master-level challenges ‚Ä¢ {filteredChallenges.length} available</p>
          </div>

          <OptimizedChallengeGrid
            challenges={filteredChallenges}
            onStartChallenge={handleStartChallenge}
            loading={loading}
            emptyMessage="No advanced challenges found"
            emptyAction={() => setCreateModalOpen(true)}
            emptyActionLabel="Create an Advanced Challenge"
            useVirtualScroll={filteredChallenges.length > 20}
          />
        </TabsContent>
      </Tabs>

      <CreateChallengeModal
        open={createModalOpen}
        onOpenChange={setCreateModalOpen}
        onChallengeCreated={handleChallengeCreated}
      />
    </>
  )
}
