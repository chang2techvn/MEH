"use server"

import { supabaseServer } from "@/lib/supabase-server"
import { Challenge } from '@/lib/utils/challenge-constants'

// Function to get today's date as batch identifier
const getTodayBatch = () => {
  const today = new Date()
  return `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`
}

// Function to save challenges to database
export async function saveChallengeToDatabase(challenge: Challenge, isAutoGenerated = true) {
  try {
    const challengeData = {
      id: challenge.id,
      title: challenge.title,
      description: challenge.description,
      challenge_type: 'VIDEO_SUBMISSION',
      difficulty_level: challenge.difficulty.toUpperCase(),
      points: 10,
      is_active: true,
      content: {
        videoUrl: challenge.videoUrl,
        embedUrl: challenge.embedUrl,
        thumbnailUrl: challenge.thumbnailUrl,
        duration: challenge.duration,
        topics: challenge.topics || [],
        isAutoGenerated,
        videoId: extractVideoId(challenge.videoUrl),
        dailyBatch: isAutoGenerated ? getTodayBatch() : null
      },
      created_at: new Date(challenge.createdAt).toISOString(),
      updated_at: new Date().toISOString()
    }

    const { data, error } = await supabaseServer
      .from('challenges')
      .upsert([challengeData], {
        onConflict: 'id',
        ignoreDuplicates: false
      })
      .select()

    if (error) {
      console.error('Error saving challenge to database:', error)
      return { success: false, error }
    }

    return { success: true, data }
  } catch (error) {
    console.error('Error in saveChallengeToDatabase:', error)
    return { success: false, error }
  }
}

// Function to extract YouTube video ID from URL
function extractVideoId(url: string): string | null {
  const regex = /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/
  const match = url.match(regex)
  return match ? match[1] : null
}

// Function to get challenges from database with pagination
export async function getChallengesFromDatabase(limit = 20, offset = 0): Promise<{ data: Challenge[]; total: number } | null> {
  try {
    // Get total count efficiently
    const { count, error: countError } = await supabaseServer
      .from('challenges')
      .select('*', { count: 'exact', head: true })
      .eq('is_active', true)

    if (countError) {
      console.error('Error getting challenges count:', countError)
      return null
    }

    // Get challenges with pagination and only necessary fields
    const { data, error } = await supabaseServer
      .from('challenges')
      .select('id, title, description, difficulty_level, content, created_at')
      .eq('is_active', true)
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1)

    if (error) {
      console.error('Error getting challenges from database:', error)
      return null
    }

    return {
      data: data?.map(convertDatabaseToChallenge) || [],
      total: count || 0
    }
  } catch (error) {
    console.error('Error in getChallengesFromDatabase:', error)
    return null
  }
}

// Function to get today's challenges from database
export async function getTodaysChallengesFromDatabase(): Promise<Challenge[] | null> {
  try {
    const todayBatch = getTodayBatch()
    
    // Get only specific fields and filter in database query
    const { data, error } = await supabaseServer
      .from('challenges')
      .select('id, title, description, difficulty_level, content, created_at')
      .eq('is_active', true)
      .or(`content->>dailyBatch.eq.${todayBatch},content->>isAutoGenerated.eq.false`)
      .order('created_at', { ascending: false })
      .limit(50) // Limit results to prevent loading too much data

    if (error) {
      console.error('Error getting challenges:', error)
      return null
    }

    // Filter and convert to Challenge format
    return data?.map(convertDatabaseToChallenge) || []
  } catch (error) {
    console.error('Error in getTodaysChallengesFromDatabase:', error)
    return null
  }
}

// Function to save multiple challenges to database with batching
export async function saveChallengesArrayToDatabase(challenges: Challenge[], isAutoGenerated = true) {
  try {
    // Process in batches of 5 to avoid overwhelming the database
    const batchSize = 5
    const batches = []
    
    for (let i = 0; i < challenges.length; i += batchSize) {
      batches.push(challenges.slice(i, i + batchSize))
    }
    
    let successCount = 0
    const errors: any[] = []
    
    // Process batches sequentially to avoid connection issues
    for (const batch of batches) {
      try {
        const batchResults = await Promise.all(
          batch.map(challenge => saveChallengeToDatabase(challenge, isAutoGenerated))
        )
        
        successCount += batchResults.filter(r => r.success).length
        errors.push(...batchResults.filter(r => !r.success).map(r => r.error))
        
        // Small delay between batches to prevent rate limiting
        if (batches.length > 1) {
          await new Promise(resolve => setTimeout(resolve, 100))
        }
      } catch (batchError) {
        console.error('Error processing batch:', batchError)
        errors.push(batchError)
      }
    }

    return {
      success: errors.length === 0,
      successCount,
      totalCount: challenges.length,
      errors: errors.length > 0 ? errors : undefined
    }
  } catch (error) {
    console.error('Error in saveChallengesArrayToDatabase:', error)
    return { success: false, error, successCount: 0, totalCount: challenges.length }
  }
}

// Function to clean up old daily challenges - optimized to avoid loading all data
export async function cleanupOldDailyChallenges() {
  try {
    // Get unique daily batches more efficiently
    const { data: batchData, error: batchError } = await supabaseServer
      .from('challenges')
      .select('content')
      .eq('is_active', true)
      .not('content->>dailyBatch', 'is', null)
      .limit(1000) // Limit to prevent memory issues

    if (batchError) {
      console.error('Error getting batch data:', batchError)
      return { success: false, error: batchError }
    }

    // Extract unique batches
    const uniqueBatches = [...new Set(batchData?.map(item => {
      const content = item.content as any
      return content?.dailyBatch
    }).filter(Boolean) || [])]
    
    let totalDeleted = 0

    // Process batches one at a time to avoid memory issues
    for (const batch of uniqueBatches) {
      if (!batch) continue

      // Count challenges for this batch first
      const { count } = await supabaseServer
        .from('challenges')
        .select('*', { count: 'exact', head: true })
        .eq('is_active', true)
        .eq('content->>dailyBatch', batch)

      if ((count || 0) > 10) {
        // Get IDs of excess challenges (oldest first)
        const { data: excessChallenges } = await supabaseServer
          .from('challenges')
          .select('id')
          .eq('is_active', true)
          .eq('content->>dailyBatch', batch)
          .order('created_at', { ascending: true })
          .limit((count || 0) - 10)

        if (excessChallenges && excessChallenges.length > 0) {
          const idsToDelete = excessChallenges.map(c => c.id)
          
          const { error: deleteError } = await supabaseServer
            .from('challenges')
            .delete()
            .in('id', idsToDelete)

          if (!deleteError) {
            totalDeleted += idsToDelete.length
          } else {
            console.error(`Error deleting old challenges for batch ${batch}:`, deleteError)
          }
        }
      }
    }

    return { success: true, deletedCount: totalDeleted }
  } catch (error) {
    console.error('Error in cleanupOldDailyChallenges:', error)
    return { success: false, error }
  }
}

// Function to cleanup expired challenges
export async function cleanupExpiredChallenges() {
  try {
    const thirtyDaysAgo = new Date()
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)

    const { data, error } = await supabaseServer
      .from('challenges')
      .update({ is_active: false })
      .lt('created_at', thirtyDaysAgo.toISOString())
      .eq('is_active', true)
      .select()

    if (error) {
      console.error('Error cleaning up expired challenges:', error)
      return { success: false, error }
    }

    console.log(`Cleaned up ${data?.length || 0} expired challenges`)
    return { success: true, data }
  } catch (error) {
    console.error('Error in cleanupExpiredChallenges:', error)
    return { success: false, error }
  }
}

// Helper function to convert database challenge to Challenge interface
function convertDatabaseToChallenge(dbChallenge: any): Challenge {
  const content = dbChallenge.content || {}
  
  // Use deterministic featured status based on challenge ID for consistency
  const featured = content.featured !== undefined ? content.featured : isChallengeFeatured(dbChallenge.id)
  
  return {
    id: dbChallenge.id,
    title: dbChallenge.title,
    description: dbChallenge.description,
    thumbnailUrl: content.thumbnailUrl || '',
    videoUrl: content.videoUrl || '',
    embedUrl: content.embedUrl || '',
    duration: content.duration || 0,
    difficulty: dbChallenge.difficulty_level?.toLowerCase() || 'beginner',
    createdAt: dbChallenge.created_at,
    topics: content.topics || [],
    featured,
    isAutoGenerated: content.isAutoGenerated || false,
    dailyBatch: content.dailyBatch || null
  }
}

// Helper function to determine if a challenge should be featured deterministically
function isChallengeFeatured(challengeId: string): boolean {
  // Use a simple hash of the ID to determine featured status consistently
  let hash = 0
  for (let i = 0; i < challengeId.length; i++) {
    const char = challengeId.charCodeAt(i)
    hash = ((hash << 5) - hash) + char
    hash = hash & hash // Convert to 32-bit integer
  }
  // About 20% of challenges will be featured
  return Math.abs(hash) % 5 === 0
}
