"use server"

import { supabase } from "@/lib/supabase"
import { Challenge } from '../utils/challenge-constants'

// Function to get today's date as batch identifier
const getTodayBatch = () => {
  const today = new Date()
  return `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`
}

// Function to save challenges to database
export async function saveChallengeToDatabase(challenge: Challenge, isAutoGenerated = true) {
  try {
    const expiresAt = new Date()
    expiresAt.setDate(expiresAt.getDate() + 30) // 30 days from now

    const challengeData = {
      id: challenge.id,
      title: challenge.title,
      description: challenge.description,
      instructions: challenge.description, // Use description as instructions for now
      difficulty: challenge.difficulty.toUpperCase() as 'BEGINNER' | 'INTERMEDIATE' | 'ADVANCED',
      category: 'LISTENING' as const, // Default category for video challenges
      type: 'VIDEO_SUBMISSION' as const, // Default type for video challenges
      points: 10,
      isActive: true,
      isPublic: true,
      tags: challenge.topics || [],
      resources: {
        videoUrl: challenge.videoUrl,
        embedUrl: challenge.embedUrl,
        thumbnailUrl: challenge.thumbnailUrl,
        duration: challenge.duration
      },
      createdAt: new Date(challenge.createdAt).toISOString(),
      updatedAt: new Date().toISOString(),
      isAutoGenerated,
      videoId: extractVideoId(challenge.videoUrl),
      dailyBatch: isAutoGenerated ? getTodayBatch() : null,
      expiresAt: isAutoGenerated ? expiresAt.toISOString() : null,
      isCompleted: false
    }

    const { data, error } = await supabase
      .from('challenges')
      .upsert([challengeData], {
        onConflict: 'id',
        ignoreDuplicates: false
      })
      .select()

    if (error) {
      console.error('Error saving challenge to database:', error)
      return { success: false, error }
    }

    return { success: true, data }
  } catch (error) {
    console.error('Error in saveChallengeToDatabase:', error)
    return { success: false, error }
  }
}

// Function to extract YouTube video ID from URL
function extractVideoId(url: string): string | null {
  const regex = /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/
  const match = url.match(regex)
  return match ? match[1] : null
}

// Function to get challenges from database with pagination
export async function getChallengesFromDatabase(limit = 20, offset = 0): Promise<{ data: Challenge[]; total: number } | null> {
  try {
    // Get total count
    const { count, error: countError } = await supabase
      .from('challenges')
      .select('*', { count: 'exact', head: true })
      .eq('isActive', true)

    if (countError) {
      console.error('Error getting challenges count:', countError)
      return null
    }

    // Get challenges with pagination
    const { data, error } = await supabase
      .from('challenges')
      .select('*')
      .eq('isActive', true)
      .order('createdAt', { ascending: false })
      .range(offset, offset + limit - 1)

    if (error) {
      console.error('Error getting challenges from database:', error)
      return null
    }

    return {
      data: data?.map(convertDatabaseToChallenge) || [],
      total: count || 0
    }
  } catch (error) {
    console.error('Error in getChallengesFromDatabase:', error)
    return null
  }
}

// Function to get today's challenges from database (latest 10 auto-generated + user-created)
export async function getTodaysChallengesFromDatabase(): Promise<Challenge[] | null> {
  try {
    const todayBatch = getTodayBatch()
    
    // Get auto-generated challenges for today (max 10)
    const { data: autoGenerated, error: autoError } = await supabase
      .from('challenges')
      .select('*')
      .eq('isAutoGenerated', true)
      .eq('dailyBatch', todayBatch)
      .eq('isActive', true)
      .order('createdAt', { ascending: false })
      .limit(10)

    if (autoError) {
      console.error('Error getting auto-generated challenges:', autoError)
      return null
    }

    // Get active user-created challenges
    const { data: userCreated, error: userError } = await supabase
      .from('challenges')
      .select('*')
      .eq('isAutoGenerated', false)
      .eq('isActive', true)
      .order('createdAt', { ascending: false })

    if (userError) {
      console.error('Error getting user-created challenges:', userError)
      return null
    }

    // Combine and convert to Challenge format
    const allChallenges = [...(autoGenerated || []), ...(userCreated || [])]
    return allChallenges.map(convertDatabaseToChallenge)
  } catch (error) {
    console.error('Error in getTodaysChallengesFromDatabase:', error)
    return null
  }
}

// Function to save multiple challenges to database
export async function saveChallengesArrayToDatabase(challenges: Challenge[], isAutoGenerated = true) {
  try {
    // If saving auto-generated challenges, clean up old ones first
    if (isAutoGenerated) {
      await cleanupOldDailyChallenges()
    }

    const results = await Promise.all(
      challenges.map(challenge => saveChallengeToDatabase(challenge, isAutoGenerated))
    )

    const successCount = results.filter(r => r.success).length
    const errors = results.filter(r => !r.success).map(r => r.error)

    return {
      success: errors.length === 0,
      successCount,
      totalCount: challenges.length,
      errors: errors.length > 0 ? errors : undefined
    }
  } catch (error) {
    console.error('Error in saveChallengesArrayToDatabase:', error)
    return { success: false, error, successCount: 0, totalCount: challenges.length }
  }
}

// Function to clean up old daily challenges (keep only latest 10 per day)
export async function cleanupOldDailyChallenges() {
  try {
    const { data, error } = await supabase.rpc('cleanup_old_daily_challenges')
    
    if (error) {
      console.error('Error cleaning up old daily challenges:', error)
      return { success: false, error }
    }

    console.log(`Cleaned up ${data} old daily challenges`)
    return { success: true, deletedCount: data }
  } catch (error) {
    console.error('Error in cleanupOldDailyChallenges:', error)
    return { success: false, error }
  }
}

// Function to clean up expired challenges
export async function cleanupExpiredChallenges() {
  try {
    const { data, error } = await supabase.rpc('cleanup_expired_challenges')
    
    if (error) {
      console.error('Error cleaning up expired challenges:', error)
      return { success: false, error }
    }

    console.log(`Cleaned up ${data} expired challenges`)
    return { success: true, deletedCount: data }
  } catch (error) {
    console.error('Error in cleanupExpiredChallenges:', error)
    return { success: false, error }
  }
}

// Function to mark challenge as completed
export async function markChallengeCompleted(challengeId: string, userId: string) {
  try {
    const { data, error } = await supabase
      .from('challenges')
      .update({
        isCompleted: true,
        completedAt: new Date().toISOString()
      })
      .eq('id', challengeId)
      .select()

    if (error) {
      console.error('Error marking challenge as completed:', error)
      return { success: false, error }
    }

    return { success: true, data }
  } catch (error) {
    console.error('Error in markChallengeCompleted:', error)
    return { success: false, error }
  }
}

// Helper function to convert database challenge to Challenge interface
function convertDatabaseToChallenge(dbChallenge: any): Challenge {
  const resources = dbChallenge.resources || {}
  
  return {
    id: dbChallenge.id,
    title: dbChallenge.title,
    description: dbChallenge.description,
    thumbnailUrl: resources.thumbnailUrl || '',
    videoUrl: resources.videoUrl || '',
    embedUrl: resources.embedUrl || '',
    duration: resources.duration || 0,
    difficulty: dbChallenge.difficulty?.toLowerCase() || 'beginner',
  createdAt: dbChallenge.createdAt,
    topics: dbChallenge.tags || [],
    featured: Math.random() < 0.2 // Random featured status
  }
}
