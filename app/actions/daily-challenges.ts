"use server"

import { fetchRandomYoutubeVideo, type VideoData } from "./youtube-video"
import { classifyChallengeDifficulty } from "@/lib/utils/challenge-classifier"
import { challengeTopics, type Challenge } from '@/lib/utils/challenge-constants'
import { saveChallengeToDatabase, getTodaysChallengesFromDatabase } from './challenge-database'

// Function to get today's date as batch identifier
const getTodayBatch = () => {
  const today = new Date()
  return `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`
}

// Function to generate a unique challenge ID
const generateChallengeId = () => {
  return `challenge_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
}

// Convert VideoData to Challenge
function videoDataToChallenge(videoData: VideoData, dailyBatch: string): Challenge {
  const difficulty = classifyChallengeDifficulty(videoData.title, videoData.description, videoData.duration)
  
  return {
    id: generateChallengeId(),
    title: videoData.title,
    description: videoData.description,
    videoUrl: videoData.videoUrl,
    embedUrl: videoData.embedUrl,
    thumbnailUrl: videoData.thumbnailUrl,    duration: videoData.duration,
    difficulty,
    topics: videoData.topics || [],
    createdAt: new Date().toISOString(),    isAutoGenerated: true,
    dailyBatch,
    featured: false
  }
}

// Diverse search topics for YouTube videos
const searchTopics = [
  "TED Talk education",
  "English learning conversation",
  "Science documentary",
  "Technology explanation",
  "History documentary",
  "Nature documentary",
  "Business presentation",
  "Language learning tips",
  "Culture and travel",
  "Health and wellness",
  "Environmental science",
  "Psychology explained",
  "Art and creativity",
  "Music education",
  "Cooking tutorial",
  "Career advice",
  "Public speaking",
  "Communication skills",
  "Leadership lessons",
  "Innovation stories"
]

// Function to generate daily challenges (reduced to 1 per day)
export async function generateDailyChallenges(count: number = 1): Promise<Challenge[]> {
  const todayBatch = getTodayBatch()
  
  try {
    // Check if we already have challenges for today
    const existingChallenges = await getTodaysChallengesFromDatabase()
    
    if (existingChallenges && existingChallenges.length >= count) {
      console.log(`‚úÖ Found ${existingChallenges.length} existing challenges for today`)
      return existingChallenges.slice(0, count)
    }

    console.log(`üéØ Generating ${count} new daily challenges for ${todayBatch}`)
    
    const challenges: Challenge[] = []
    const usedVideoIds = new Set<string>()
    
    // API key failure tracking
    let apiKeyFailures = 0
    const maxApiKeyFailures = 5
    
    // Generate challenges with retry logic
    let attempts = 0
    const maxAttempts = count * 5 // Allow more attempts for 1 challenge

    while (challenges.length < count && attempts < maxAttempts && apiKeyFailures < maxApiKeyFailures) {
      attempts++
      
      try {
        // Pick a random search topic
        const randomTopic = searchTopics[Math.floor(Math.random() * searchTopics.length)]
        
        console.log(`üì∫ Attempt ${attempts}: Fetching video for topic "${randomTopic}" (API failures: ${apiKeyFailures}/${maxApiKeyFailures})`)
        
        // Fetch a random YouTube video
        const videoData = await fetchRandomYoutubeVideo(
          60,    // min duration: 1 minute
          1800,  // max duration: 30 minutes
          [randomTopic]
        )

        // Check for duplicates
        if (usedVideoIds.has(videoData.id)) {
          console.log(`‚ö†Ô∏è Duplicate video found: ${videoData.id}, skipping...`)
          continue
        }

        // Convert to challenge
        const challenge = videoDataToChallenge(videoData, todayBatch)
        
        // Save to database
        const saveResult = await saveChallengeToDatabase(challenge, true)
        
        if (saveResult.success) {
          challenges.push(challenge)
          usedVideoIds.add(videoData.id)
          console.log(`‚úÖ Challenge ${challenges.length}/${count} created: "${challenge.title}" (${challenge.difficulty})`)
        } else {
          console.log(`‚ùå Failed to save challenge: ${saveResult.error}`)
        }

      } catch (error) {
        console.log(`‚ö†Ô∏è Failed to fetch video on attempt ${attempts}:`, error instanceof Error ? error.message : error)
        
        // Check if error is related to API key issues
        const errorMessage = error instanceof Error ? error.message : String(error)
        if (errorMessage.includes('API key') || 
            errorMessage.includes('403') || 
            errorMessage.includes('401') ||
            errorMessage.includes('quota') ||
            errorMessage.includes('overloaded') ||
            errorMessage.includes('503')) {
          apiKeyFailures++
          console.log(`üîÑ API key related error detected. Failures: ${apiKeyFailures}/${maxApiKeyFailures}`)
          
          if (apiKeyFailures >= maxApiKeyFailures) {
            console.log(`‚ùå Maximum API key failures reached (${maxApiKeyFailures}). Stopping challenge generation for today.`)
            break
          }
        }
        
        // If we can't fetch videos and haven't hit API key limit, try fallback
        if (attempts > count && apiKeyFailures < maxApiKeyFailures) {
          try {
            console.log('üîÑ Using fallback video generation with real transcript extraction...')
            const fallbackChallenge = await createFallbackChallenge(todayBatch, challenges.length + 1)
            if (fallbackChallenge) {
              const saveResult = await saveChallengeToDatabase(fallbackChallenge, true)
              if (saveResult.success) {
                challenges.push(fallbackChallenge)
                console.log(`‚úÖ Fallback challenge ${challenges.length}/${count} created with real transcript`)
              }
            }
          } catch (fallbackError) {
            console.log('‚ùå Fallback challenge creation also failed:', fallbackError)
            const fallbackErrorMessage = fallbackError instanceof Error ? fallbackError.message : String(fallbackError)
            if (fallbackErrorMessage.includes('API key') || 
                fallbackErrorMessage.includes('403') || 
                fallbackErrorMessage.includes('401') ||
                fallbackErrorMessage.includes('quota') ||
                fallbackErrorMessage.includes('overloaded') ||
                fallbackErrorMessage.includes('503')) {
              apiKeyFailures++
              console.log(`üîÑ API key failure in fallback. Total failures: ${apiKeyFailures}/${maxApiKeyFailures}`)
            }
          }
        }
      }
      
      // Add a small delay to avoid rate limiting
      if (attempts % 3 === 0) {
        await new Promise(resolve => setTimeout(resolve, 1000))
      }
    }

    // Check final status
    if (apiKeyFailures >= maxApiKeyFailures) {
      console.log(`‚õî Challenge generation stopped due to API key failures. Generated ${challenges.length}/${count} challenges.`)
    } else if (challenges.length < count) {
      console.log(`‚ö†Ô∏è Warning: Only generated ${challenges.length}/${count} challenges after ${attempts} attempts`)
    }

    console.log(`üéâ Daily challenges generation completed: ${challenges.length} challenges created`)
    return challenges

  } catch (error) {
    console.error('‚ùå Error generating daily challenges:', error)
    throw error
  }
}

// Fallback challenge creation when YouTube fetching fails
async function createFallbackChallenge(dailyBatch: string, index: number): Promise<Challenge | null> {
  // Predefined fallback video data
  const fallbackVideos = [
    {
      id: "J---aiyznGQ",
      title: "English Learning: Essential Communication Skills",
      description: "Master the fundamental communication skills needed for professional and personal success in English.",
      duration: 300,
      topics: ["Communication", "Business English", "Professional Development"]
    },
    {
      id: "Ks-_Mh1QhMc", 
      title: "Advanced English Grammar in Context",
      description: "Learn advanced grammar concepts through real-world examples and practical applications.",
      duration: 420,
      topics: ["Grammar", "Advanced English", "Language Learning"]
    },
    {
      id: "RVmMeMcGc0I",
      title: "English Pronunciation and Accent Training", 
      description: "Improve your English pronunciation with expert techniques and practice exercises.",
      duration: 360,
      topics: ["Pronunciation", "Speaking Skills", "Accent Training"]
    },
    {
      id: "fLJsdqxnZb0",
      title: "Business English for Global Communication",
      description: "Essential business English skills for international communication and professional success.",
      duration: 480,
      topics: ["Business English", "Professional Communication", "International Business"]
    },
    {
      id: "UF8uR6Z6KLc",
      title: "English Vocabulary Building Strategies",
      description: "Effective strategies to expand your English vocabulary and improve comprehension.",
      duration: 330,
      topics: ["Vocabulary", "Learning Strategies", "Language Acquisition"]
    }
  ]

  try {
    const fallbackData = fallbackVideos[(index - 1) % fallbackVideos.length]
    
    // Try to extract real transcript from the fallback video
    let transcript = "Transcript not available.";
    try {
      const { extractYouTubeTranscript } = await import('../../lib/utils/video-processor');
      transcript = await extractYouTubeTranscript(fallbackData.id);
      console.log(`‚úÖ Successfully extracted real transcript for fallback video ${fallbackData.id}`);
    } catch (transcriptError) {
      console.log(`‚ùå Failed to extract transcript for fallback video ${fallbackData.id}:`, transcriptError);
      // Don't create challenge if we can't get real transcript
      throw new Error(`Failed to extract real transcript for fallback video ${fallbackData.id}`);
    }
    
    const videoData: VideoData = {
      ...fallbackData,
      videoUrl: `https://www.youtube.com/watch?v=${fallbackData.id}`,
      embedUrl: `https://www.youtube.com/embed/${fallbackData.id}`,
      thumbnailUrl: `https://img.youtube.com/vi/${fallbackData.id}/maxresdefault.jpg`,
      transcript
    }

    return videoDataToChallenge(videoData, dailyBatch)
  } catch (error) {
    console.error('Error creating fallback challenge:', error)
    throw error; // Re-throw to prevent creation of challenge without real transcript
  }
}

// Function to check if daily challenges need refresh
export async function checkDailyChallengesStatus(): Promise<{
  needsRefresh: boolean
  existingCount: number
  lastRefresh: string | null
}> {
  try {
    const todayBatch = getTodayBatch()
    const existingChallenges = await getTodaysChallengesFromDatabase()
    
    return {
      needsRefresh: !existingChallenges || existingChallenges.length < 10,
      existingCount: existingChallenges?.length || 0,
      lastRefresh: existingChallenges && existingChallenges.length > 0 ? todayBatch : null
    }
  } catch (error) {
    console.error('Error checking daily challenges status:', error)
    return {
      needsRefresh: true,
      existingCount: 0,
      lastRefresh: null
    }
  }
}


export async function manuallyRefreshDailyChallenges(): Promise<{
  success: boolean
  challenges: Challenge[]
  message: string
}> {
  try {
    console.log('üîÑ Manually refreshing daily challenges...')
    const challenges = await generateDailyChallenges(1) // Changed to 1 challenge per day
    
    return {
      success: true,
      challenges,
      message: `Successfully generated ${challenges.length} daily challenges`
    }
  } catch (error) {
    console.error('Manual refresh failed:', error)
    return {
      success: false,
      challenges: [],
      message: `Failed to refresh challenges: ${error instanceof Error ? error.message : 'Unknown error'}`
    }
  }
}

// Function to get 20 challenges for display from database
export async function getPracticeChallenges(limit: number = 20): Promise<Challenge[]> {
  try {
    console.log(`üìö Fetching ${limit} practice challenges from database...`)
    
    // Import the database function
    const { getChallengesFromDatabase } = await import('./challenge-database')
    
    // Get challenges from database
    const result = await getChallengesFromDatabase(limit, 0)
    
    if (result && result.data && result.data.length > 0) {
      console.log(`‚úÖ Found ${result.data.length} practice challenges`)
      return result.data
    } else {
      console.log(`‚ö†Ô∏è No challenges found in database, generating new ones...`)
      // If no challenges exist, generate some initial ones
      await generateDailyChallenges(3)
      const newResult = await getChallengesFromDatabase(limit, 0)
      return newResult?.data || []
    }
    
  } catch (error) {
    console.error('Error fetching practice challenges:', error)
    return []
  }
}
