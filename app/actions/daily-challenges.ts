"use server"

import { fetchRandomYoutubeVideo, type VideoData } from "./youtube-video"
import { classifyChallengeDifficulty } from "../utils/challenge-classifier"
import { challengeTopics, type Challenge } from '../utils/challenge-constants'
import { saveChallengeToDatabase, getTodaysChallengesFromDatabase } from './challenge-database'

// Function to get today's date as batch identifier
const getTodayBatch = () => {
  const today = new Date()
  return `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`
}

// Function to generate a unique challenge ID
const generateChallengeId = () => {
  return `challenge_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
}

// Convert VideoData to Challenge
function videoDataToChallenge(videoData: VideoData, dailyBatch: string): Challenge {
  const difficulty = classifyChallengeDifficulty(videoData.title, videoData.description, videoData.duration)
  
  return {
    id: generateChallengeId(),
    title: videoData.title,
    description: videoData.description,
    videoUrl: videoData.videoUrl,
    embedUrl: videoData.embedUrl,
    thumbnailUrl: videoData.thumbnailUrl,    duration: videoData.duration,
    difficulty,
    topics: videoData.topics || [],
    createdAt: new Date().toISOString(),    isAutoGenerated: true,
    dailyBatch,
    featured: false
  }
}

// Diverse search topics for YouTube videos
const searchTopics = [
  "TED Talk education",
  "English learning conversation",
  "Science documentary",
  "Technology explanation",
  "History documentary",
  "Nature documentary",
  "Business presentation",
  "Language learning tips",
  "Culture and travel",
  "Health and wellness",
  "Environmental science",
  "Psychology explained",
  "Art and creativity",
  "Music education",
  "Cooking tutorial",
  "Career advice",
  "Public speaking",
  "Communication skills",
  "Leadership lessons",
  "Innovation stories"
]

// Function to generate daily challenges
export async function generateDailyChallenges(count: number = 10): Promise<Challenge[]> {
  const todayBatch = getTodayBatch()
  
  try {
    // Check if we already have challenges for today
    const existingChallenges = await getTodaysChallengesFromDatabase()
    
    if (existingChallenges && existingChallenges.length >= count) {
      console.log(`âœ… Found ${existingChallenges.length} existing challenges for today`)
      return existingChallenges.slice(0, count)
    }

    console.log(`ðŸŽ¯ Generating ${count} new daily challenges for ${todayBatch}`)
    
    const challenges: Challenge[] = []
    const usedVideoIds = new Set<string>()
    
    // Generate challenges with retry logic
    let attempts = 0
    const maxAttempts = count * 3 // Allow more attempts to avoid duplicates

    while (challenges.length < count && attempts < maxAttempts) {
      attempts++
      
      try {
        // Pick a random search topic
        const randomTopic = searchTopics[Math.floor(Math.random() * searchTopics.length)]
        
        console.log(`ðŸ“º Attempt ${attempts}: Fetching video for topic "${randomTopic}"`)
        
        // Fetch a random YouTube video
        const videoData = await fetchRandomYoutubeVideo(
          60,    // min duration: 1 minute
          1800,  // max duration: 30 minutes
          [randomTopic]
        )

        // Check for duplicates
        if (usedVideoIds.has(videoData.id)) {
          console.log(`âš ï¸ Duplicate video found: ${videoData.id}, skipping...`)
          continue
        }

        // Convert to challenge
        const challenge = videoDataToChallenge(videoData, todayBatch)
        
        // Save to database
        const saveResult = await saveChallengeToDatabase(challenge, true)
        
        if (saveResult.success) {
          challenges.push(challenge)
          usedVideoIds.add(videoData.id)
          console.log(`âœ… Challenge ${challenges.length}/${count} created: "${challenge.title}" (${challenge.difficulty})`)
        } else {
          console.log(`âŒ Failed to save challenge: ${saveResult.error}`)
        }

      } catch (error) {
        console.log(`âš ï¸ Failed to fetch video on attempt ${attempts}:`, error instanceof Error ? error.message : error)
        
        // If we can't fetch videos, try again with a different approach
        if (attempts > count) {
          // Use fallback videos if available
          console.log('ðŸ”„ Using fallback video generation...')
          try {
            const fallbackChallenge = await createFallbackChallenge(todayBatch, challenges.length + 1)
            if (fallbackChallenge) {
              const saveResult = await saveChallengeToDatabase(fallbackChallenge, true)
              if (saveResult.success) {
                challenges.push(fallbackChallenge)
                console.log(`âœ… Fallback challenge ${challenges.length}/${count} created`)
              }
            }
          } catch (fallbackError) {
            console.log('âŒ Fallback challenge creation failed:', fallbackError)
          }
        }
      }
      
      // Add a small delay to avoid rate limiting
      if (attempts % 3 === 0) {
        await new Promise(resolve => setTimeout(resolve, 1000))
      }
    }

    if (challenges.length < count) {
      console.log(`âš ï¸ Warning: Only generated ${challenges.length}/${count} challenges`)
    }

    console.log(`ðŸŽ‰ Daily challenges generation completed: ${challenges.length} challenges created`)
    return challenges

  } catch (error) {
    console.error('âŒ Error generating daily challenges:', error)
    throw error
  }
}

// Fallback challenge creation when YouTube fetching fails
async function createFallbackChallenge(dailyBatch: string, index: number): Promise<Challenge | null> {
  // Predefined fallback video data
  const fallbackVideos = [
    {
      id: "J---aiyznGQ",
      title: "English Learning: Essential Communication Skills",
      description: "Master the fundamental communication skills needed for professional and personal success in English.",
      duration: 300,
      topics: ["Communication", "Business English", "Professional Development"]
    },
    {
      id: "Ks-_Mh1QhMc", 
      title: "Advanced English Grammar in Context",
      description: "Learn advanced grammar concepts through real-world examples and practical applications.",
      duration: 420,
      topics: ["Grammar", "Advanced English", "Language Learning"]
    },
    {
      id: "RVmMeMcGc0I",
      title: "English Pronunciation and Accent Training", 
      description: "Improve your English pronunciation with expert techniques and practice exercises.",
      duration: 360,
      topics: ["Pronunciation", "Speaking Skills", "Accent Training"]
    },
    {
      id: "fLJsdqxnZb0",
      title: "Business English for Global Communication",
      description: "Essential business English skills for international communication and professional success.",
      duration: 480,
      topics: ["Business English", "Professional Communication", "International Business"]
    },
    {
      id: "UF8uR6Z6KLc",
      title: "English Vocabulary Building Strategies",
      description: "Effective strategies to expand your English vocabulary and improve comprehension.",
      duration: 330,
      topics: ["Vocabulary", "Learning Strategies", "Language Acquisition"]
    }
  ]

  try {
    const fallbackData = fallbackVideos[(index - 1) % fallbackVideos.length]
    
    const videoData: VideoData = {
      ...fallbackData,
      videoUrl: `https://www.youtube.com/watch?v=${fallbackData.id}`,
      embedUrl: `https://www.youtube.com/embed/${fallbackData.id}`,
      thumbnailUrl: `https://img.youtube.com/vi/${fallbackData.id}/maxresdefault.jpg`,
      transcript: "Transcript not available for fallback video."
    }

    return videoDataToChallenge(videoData, dailyBatch)
  } catch (error) {
    console.error('Error creating fallback challenge:', error)
    return null
  }
}

// Function to check if daily challenges need refresh
export async function checkDailyChallengesStatus(): Promise<{
  needsRefresh: boolean
  existingCount: number
  lastRefresh: string | null
}> {
  try {
    const todayBatch = getTodayBatch()
    const existingChallenges = await getTodaysChallengesFromDatabase()
    
    return {
      needsRefresh: !existingChallenges || existingChallenges.length < 10,
      existingCount: existingChallenges?.length || 0,
      lastRefresh: existingChallenges && existingChallenges.length > 0 ? todayBatch : null
    }
  } catch (error) {
    console.error('Error checking daily challenges status:', error)
    return {
      needsRefresh: true,
      existingCount: 0,
      lastRefresh: null
    }
  }
}

// Manual trigger for generating daily challenges (for testing)
export async function manuallyRefreshDailyChallenges(): Promise<{
  success: boolean
  challenges: Challenge[]
  message: string
}> {
  try {
    console.log('ðŸ”„ Manually refreshing daily challenges...')
    const challenges = await generateDailyChallenges(10)
    
    return {
      success: true,
      challenges,
      message: `Successfully generated ${challenges.length} daily challenges`
    }
  } catch (error) {
    console.error('Manual refresh failed:', error)
    return {
      success: false,
      challenges: [],
      message: `Failed to refresh challenges: ${error instanceof Error ? error.message : 'Unknown error'}`
    }
  }
}
