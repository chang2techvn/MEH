"use server"

import { fetchRandomYoutubeVideo, type VideoData } from "./youtube-video"
import { classifyChallengeDifficulty } from "@/lib/utils/challenge-classifier"
import { challengeTopics, type Challenge } from '@/lib/utils/challenge-constants'
import { supabaseServer } from "@/lib/supabase-server"
import type { Database } from "@/lib/database.types"

// Function to get today's date as a string (YYYY-MM-DD format)
const getTodayDate = () => {
  const today = new Date()
  return `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`
}



// H√†m chuy·ªÉn ƒë·ªïi VideoData th√†nh Challenge
function videoDataToChallenge(videoData: VideoData, forceDifficulty?: string): Challenge {
  const difficulty =
    forceDifficulty || classifyChallengeDifficulty(videoData.title, videoData.description, videoData.duration)

  const today = getTodayDate()
  
  return {
    id: videoData.id,
    title: videoData.title,
    description: videoData.description,
    thumbnailUrl: videoData.thumbnailUrl,
    videoUrl: videoData.videoUrl,
    embedUrl: videoData.embedUrl,
    duration: videoData.duration,
    difficulty,
    createdAt: new Date().toISOString(),
    topics: Array.isArray(videoData.topics) ? videoData.topics : [],
    featured: Math.random() < 0.2, // 20% chance to be featured
    isAutoGenerated: true,
    dailyBatch: today
  }
}

// H√†m l·∫•y video cho m·ªôt c·∫•p ƒë·ªô c·ª• th·ªÉ
export async function fetchChallengesByDifficulty(
  difficulty: "beginner" | "intermediate" | "advanced",
  count = 2,
): Promise<Challenge[]> {
  const challenges: Challenge[] = []
  const topics = challengeTopics[difficulty] || []

  // Thi·∫øt l·∫≠p th·ªùi l∆∞·ª£ng video d·ª±a tr√™n c·∫•p ƒë·ªô
  let minDuration = 60 // 2 ph√∫t
  let maxDuration = 2700 // 5 ph√∫t

  if (difficulty === "beginner") {
    minDuration = 120 // 2 ph√∫t
    maxDuration = 2700 // 4 ph√∫t
  } else if (difficulty === "intermediate") {
    minDuration = 180 // 3 ph√∫t
    maxDuration = 2700 // 5 ph√∫t
  } else if (difficulty === "advanced") {
    minDuration = 240 // 4 ph√∫t
    maxDuration = 2700 // 7 ph√∫t
  }

  // L·∫•y ng·∫´u nhi√™n c√°c ch·ªß ƒë·ªÅ t·ª´ danh s√°ch
  const shuffledTopics = [...(Array.isArray(topics) ? topics : [])].sort(() => 0.5 - Math.random())
  const selectedTopics = shuffledTopics.slice(0, count)

  // L·∫•y video cho m·ªói ch·ªß ƒë·ªÅ
  for (const topic of selectedTopics) {
    try {
      const videoData = await fetchRandomYoutubeVideo(minDuration, maxDuration, [topic])
      const challenge = videoDataToChallenge(videoData, difficulty)
      challenges.push(challenge)
    } catch (error) {
      console.error(`Error fetching video for topic ${topic}:`, error)
    }
  }

  return challenges
}

// New Supabase-only implementation for challenges
export async function fetchAllChallenges(): Promise<Challenge[]> {
  const today = getTodayDate()
  
  try {
    console.log(`üìä Fetching today's challenges from Supabase (${today})...`)
    
    // 1. Check Supabase for today's challenges
    const { data, error } = await supabaseServer
      .from('daily_challenges')
      .select('*')
      .eq('date', today)
      .order('created_at')
      
    if (data && !error && data.length > 0) {
      console.log(`‚úÖ Found ${data.length} challenges in Supabase for today`)      // Convert Supabase data to Challenge format
      return data.map(row => {
        const challenge = row as any // Type casting to bypass TypeScript issues temporarily
        return {          id: challenge.id,
          title: challenge.title,
          description: challenge.description || "Educational challenge",
          thumbnailUrl: challenge.thumbnail_url || `https://img.youtube.com/vi/${challenge.id}/hqdefault.jpg`,
          videoUrl: challenge.video_url,
          embedUrl: challenge.embed_url || `https://www.youtube.com/embed/${challenge.id}`,
          duration: challenge.duration || 300,
          difficulty: challenge.difficulty,
          createdAt: challenge.created_at || new Date().toISOString(),
          topics: challenge.topics || [],
          featured: challenge.featured || false,
          isAutoGenerated: true,
          dailyBatch: today,
          transcript: challenge.transcript || undefined
        }
      })
    }
      console.log("‚ö†Ô∏è No challenges found in Supabase for today. Auto-triggering daily refresh...")
    
    // Auto-trigger daily refresh when no challenges found
    try {
      const { triggerDailyRefresh } = await import('./trigger-daily-refresh')
      const refreshResult = await triggerDailyRefresh()
      
      if (refreshResult.success) {
        console.log("‚úÖ Auto-refresh completed successfully")
        
        // Try fetching challenges again after refresh
        const { data: newData, error: newError } = await supabaseServer
          .from('daily_challenges')
          .select('*')
          .eq('date', today)
          .order('created_at')
        
        if (newData && !newError && newData.length > 0) {
          console.log(`‚úÖ Found ${newData.length} challenges after auto-refresh`)
          return newData.map(row => {
            const challenge = row as any
            return {
              id: challenge.id,
              title: challenge.title,
              description: challenge.description || "Educational challenge",
              thumbnailUrl: challenge.thumbnail_url || `https://img.youtube.com/vi/${challenge.id}/hqdefault.jpg`,
              videoUrl: challenge.video_url,
              embedUrl: challenge.embed_url || `https://www.youtube.com/embed/${challenge.id}`,
              duration: challenge.duration || 300,
              difficulty: challenge.difficulty,
              createdAt: challenge.created_at || new Date().toISOString(),
              topics: challenge.topics || [],
              featured: challenge.featured || false,
              isAutoGenerated: true,
              dailyBatch: today,
              transcript: challenge.transcript || undefined
            }
          })
        }
      } else {
        console.error("‚ùå Auto-refresh failed:", refreshResult.message)
      }
    } catch (refreshError) {
      console.error("‚ùå Error during auto-refresh:", refreshError)
    }
    
    console.log("‚ö†Ô∏è No challenges available even after auto-refresh")
    return []
    
  } catch (error) {
    console.error("‚ùå Error fetching challenges from Supabase:", error)
    return []
  }
}

// H√†m l·∫•y th·ª≠ th√°ch hi·ªán t·∫°i cho ng∆∞·ªùi d√πng (homepage)
export async function fetchCurrentChallenge(): Promise<Challenge | null> {
  try {
    const today = getTodayDate()
    
    console.log("üîç Checking Supabase for today's current challenge")
    
    // Get today's challenges from Supabase
    const challenges = await fetchAllChallenges()
    
    if (challenges.length > 0) {
      // Use the first challenge as current challenge
      const currentChallenge = challenges[0]
      console.log("‚úÖ Using first challenge as current challenge:", currentChallenge.id)
      return currentChallenge
    }

    console.log("‚ö†Ô∏è No current challenge found for today. Waiting for cron job to generate new challenges.")
    return null

  } catch (error) {
    console.error("‚ùå Error fetching current challenge:", error)
    return null
  }
}

// Generate 10 challenges for the day - OPTIMIZED VERSION
export async function generateDailyChallenges(): Promise<Challenge[]> {
  const today = getTodayDate()
  const challenges: Challenge[] = []
  const usedVideoIds = new Set<string>() // Track used video IDs to prevent duplicates
  
  try {
    console.log(`üöÄ Generating 10 challenges for ${today}...`)
    
    // Distribution: 3 beginner, 4 intermediate, 3 advanced
    const difficulties = [
      ...Array(3).fill('beginner'),
      ...Array(4).fill('intermediate'), 
      ...Array(3).fill('advanced')
    ]
    
    // Generate ALL challenges in parallel for maximum speed
    console.log(`‚ö° Generating all 10 challenges in parallel...`)
    
    const challengePromises = difficulties.map(async (difficulty, index) => {
      const difficultyType = difficulty as 'beginner' | 'intermediate' | 'advanced'
      
      try {
        console.log(`üìπ Starting ${difficultyType} challenge ${index + 1}/10...`)
        
        // Duration based on difficulty - reduced durations for faster generation
        let minDuration = 60, maxDuration = 600 // Max 10 minutes for faster processing
        if (difficultyType === 'beginner') {
          minDuration = 60  // 1 min
          maxDuration = 10000 // 4 min
        } else if (difficultyType === 'intermediate') {
          minDuration = 120 // 2 min  
          maxDuration = 20000 // 6 min
        } else {
          minDuration = 180 // 3 min
          maxDuration = 30000 // 10 min
        }
        
        // Only retry once to speed up generation
        let attempts = 0
        let videoData: VideoData | null = null
        
        while (attempts < 2 && !videoData) { // Reduced from 3 to 2 attempts
          attempts++
          try {
            const candidateVideo = await fetchRandomYoutubeVideo(
              minDuration,
              maxDuration,
              ["english", "education", "learning"] // Simplified search terms
            )
            
            // For parallel execution, we'll check duplicates later
            videoData = candidateVideo
            break
            
          } catch (error) {
            console.error(`‚ùå Attempt ${attempts} failed for ${difficultyType} challenge:`, error)
          }
        }
        
        if (!videoData) {
          console.error(`‚ùå Failed to get video for ${difficultyType} challenge after 2 attempts`)
          return null
        }
          const challenge = videoDataToChallenge(videoData, difficultyType)
        
        // Extract transcript using Gemini AI
        let transcript = videoData.transcript || ""
        
        if (!transcript || transcript === "Transcript unavailable" || transcript.length < 100) {
          try {
            console.log(`ü§ñ Extracting transcript for ${difficultyType} challenge: ${challenge.id}`)
            const { GoogleGenerativeAI } = await import('@google/generative-ai')
            
            if (process.env.GEMINI_API_KEY) {
              const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY)
              const model = genAI.getGenerativeModel({ 
                model: "gemini-1.5-flash" // Use flash to save quota
              })

              const youtubeUrl = `https://www.youtube.com/watch?v=${challenge.id}`

              const result = await model.generateContent([
                {
                  fileData: {
                    mimeType: "video/*",
                    fileUri: youtubeUrl
                  }
                },
                `Please provide the COMPLETE and ACCURATE transcript of this YouTube video.

REQUIREMENTS:
- Extract 100% of all spoken words from the entire video
- Include every single word that is spoken  
- Format as clean paragraphs with proper punctuation
- Do NOT summarize or paraphrase - give exact spoken words
- If there are multiple speakers, indicate speaker changes

Please transcribe the ENTIRE audio content word-for-word:`
              ])

              const response = await result.response
              const geminiTranscript = response.text()
              
              if (geminiTranscript && geminiTranscript.length > 50) {
                transcript = geminiTranscript.trim()
                console.log(`‚úÖ Gemini AI transcript extracted for ${challenge.id}: ${transcript.length} characters`)
              } else {
                console.log(`‚ö†Ô∏è Gemini AI returned short transcript for ${challenge.id}, using fallback`)
                transcript = `Educational content about ${challenge.title}. ${challenge.description}`
              }
            } else {
              console.log(`‚ö†Ô∏è No GEMINI_API_KEY, using fallback transcript for ${challenge.id}`)
              transcript = `Educational content about ${challenge.title}. ${challenge.description}`
            }
          } catch (error) {
            console.error(`‚ùå Gemini AI transcript failed for ${challenge.id}:`, error)
            transcript = `Educational content about ${challenge.title}. ${challenge.description}`
          }
        }
        
        // Add transcript to challenge object
        challenge.transcript = transcript
        
        console.log(`‚úÖ Generated ${difficultyType} challenge: ${challenge.title} (${challenge.id})`)
        
        return challenge
        
      } catch (error) {
        console.error(`‚ùå Error generating ${difficultyType} challenge:`, error)
        return null
      }
    })
    
    // Wait for ALL challenges to complete in parallel
    console.log(`‚è≥ Waiting for all 10 challenges to complete...`)
    const allResults = await Promise.all(challengePromises)
    
    // Filter out nulls and handle duplicates
    const validChallenges = allResults.filter(Boolean) as Challenge[]
    
    // Remove duplicates based on video ID
    for (const challenge of validChallenges) {
      if (!usedVideoIds.has(challenge.id)) {
        usedVideoIds.add(challenge.id)
        challenges.push(challenge)
      } else {
        console.log(`üîÑ Skipping duplicate video: ${challenge.id}`)
      }
    }
    
    console.log(`üéØ Generated ${challenges.length} unique challenges out of ${validChallenges.length} total`)
    
    // If we have less than 10 unique challenges, add some fallback logic
    if (challenges.length < 10) {
      console.log(`‚ö†Ô∏è Only ${challenges.length} unique challenges generated, proceeding with what we have`)
    }
      // Save all challenges to Supabase
    if (challenges.length > 0) {
      console.log(`üíæ Saving ${challenges.length} challenges to Supabase...`)
        const challengeRows = challenges.map(challenge => ({
        id: challenge.id,
        title: challenge.title,
        description: challenge.description,
        video_url: challenge.videoUrl,
        thumbnail_url: challenge.thumbnailUrl,
        embed_url: challenge.embedUrl,
        duration: challenge.duration,
        topics: challenge.topics,
        difficulty: challenge.difficulty,
        featured: challenge.featured,
        transcript: challenge.transcript || null,
        date: today,
        created_at: new Date().toISOString()
      }))
      
      // Use upsert instead of insert to handle duplicates gracefully
      const { error } = await supabaseServer
        .from('daily_challenges')
        .upsert(challengeRows, { 
          onConflict: 'id',
          ignoreDuplicates: false 
        })
      
      if (error) {
        console.error("‚ùå Error saving challenges to Supabase:", error)
        throw error
      }
      
      console.log(`‚úÖ Successfully saved ${challenges.length} challenges to Supabase`)
    }
    
    return challenges
    
  } catch (error) {
    console.error("‚ùå Error generating daily challenges:", error)
    return challenges // Return whatever we managed to generate
  }
}
