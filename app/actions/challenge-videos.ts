"use server"

import { fetchRandomYoutubeVideo, type VideoData } from "./youtube-video"
import { classifyChallengeDifficulty } from "../utils/challenge-classifier"
import { challengeTopics, type Challenge } from '../utils/challenge-constants'
import { 
  saveChallengesArrayToDatabase, 
  getTodaysChallengesFromDatabase,
  saveChallengeToDatabase 
} from './challenge-database'



// Add these cache variables at the top of the file, after the imports
// Cache mechanism for challenges
type ChallengeCache = {
  challenges: Challenge[]
  date: string | null
  timestamp: number
}

// Global cache for challenges
let globalChallengeCache: ChallengeCache = {
  challenges: [],
  date: null,
  timestamp: 0,
}

// Cache for current challenge
let currentChallengeCache: {
  challenge: Challenge | null
  date: string | null
} = {
  challenge: null,
  date: null,
}

// Function to get today's date as a string (YYYY-MM-DD format)
const getTodayDate = () => {
  const today = new Date()
  return `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`
}



// Hàm chuyển đổi VideoData thành Challenge
function videoDataToChallenge(videoData: VideoData, forceDifficulty?: string, isAutoGenerated = true): Challenge {
  const difficulty =
    forceDifficulty || classifyChallengeDifficulty(videoData.title, videoData.description, videoData.duration)

  const today = getTodayDate()
  
  return {
    id: videoData.id,
    title: videoData.title,
    description: videoData.description,
    thumbnailUrl: videoData.thumbnailUrl,
    videoUrl: videoData.videoUrl,
    embedUrl: videoData.embedUrl,
    duration: videoData.duration,
    difficulty,
    createdAt: new Date().toISOString(),
    topics: Array.isArray(videoData.topics) ? videoData.topics : [],
    featured: Math.random() < 0.2, // 20% chance to be featured
    isAutoGenerated,
    dailyBatch: isAutoGenerated ? today : null
  }
}

// Hàm lấy video cho một cấp độ cụ thể
export async function fetchChallengesByDifficulty(
  difficulty: "beginner" | "intermediate" | "advanced",
  count = 2,
): Promise<Challenge[]> {
  const challenges: Challenge[] = []
  const topics = challengeTopics[difficulty] || []

  // Thiết lập thời lượng video dựa trên cấp độ
  let minDuration = 60 // 2 phút
  let maxDuration = 2700 // 5 phút

  if (difficulty === "beginner") {
    minDuration = 120 // 2 phút
    maxDuration = 2700 // 4 phút
  } else if (difficulty === "intermediate") {
    minDuration = 180 // 3 phút
    maxDuration = 2700 // 5 phút
  } else if (difficulty === "advanced") {
    minDuration = 240 // 4 phút
    maxDuration = 2700 // 7 phút
  }

  // Lấy ngẫu nhiên các chủ đề từ danh sách
  const shuffledTopics = [...(Array.isArray(topics) ? topics : [])].sort(() => 0.5 - Math.random())
  const selectedTopics = shuffledTopics.slice(0, count)

  // Lấy video cho mỗi chủ đề
  for (const topic of selectedTopics) {
    try {
      const videoData = await fetchRandomYoutubeVideo(minDuration, maxDuration, [topic])
      const challenge = videoDataToChallenge(videoData, difficulty)
      challenges.push(challenge)
    } catch (error) {
      console.error(`Error fetching video for topic ${topic}:`, error)
    }
  }

  return challenges
}

// Hàm lấy tất cả các thử thách cho trang challenges
export async function fetchAllChallenges(countPerDifficulty = 3): Promise<Challenge[]> {
  try {
    const today = getTodayDate()
    console.log(`Fetching challenges for date: ${today}`)
    
    // Try to get today's challenges from database first
    const dbResult = await getTodaysChallengesFromDatabase()
    
    // Count auto-generated challenges for today
    const todayAutoGenerated = dbResult?.filter(c => 
      c.isAutoGenerated && c.dailyBatch === today
    ) || []
    
    // If we have at least 10 auto-generated challenges for today, use them
    if (todayAutoGenerated.length >= 10) {
      console.log(`Using ${todayAutoGenerated.length} auto-generated challenges from database for today`)
      // Update cache with database data
      globalChallengeCache = {
        challenges: dbResult || [],
        date: today,
        timestamp: Date.now(),
      }
      return dbResult || []
    }

    // Check if we have cached challenges for today with enough count
    if (globalChallengeCache.challenges.length >= 10 && globalChallengeCache.date === today) {
      const cachedAutoGenerated = globalChallengeCache.challenges.filter(c => 
        c.isAutoGenerated && c.dailyBatch === today
      )
      if (cachedAutoGenerated.length >= 10) {
        console.log("Using cached challenges for today")
        return globalChallengeCache.challenges
      }
    }

    console.log("Fetching new daily challenges (10 videos)")

    // Generate exactly 10 new auto-generated challenges for today
    const newChallenges: Challenge[] = []
    const difficulties = ["beginner", "intermediate", "advanced"] as const
    const targetPerDifficulty = Math.ceil(10 / difficulties.length)
    
    for (const difficulty of difficulties) {
      const count = Math.min(targetPerDifficulty, 10 - newChallenges.length)
      if (count > 0) {
        const difficultyChallenges = await fetchChallengesByDifficulty(difficulty, count)
        newChallenges.push(...difficultyChallenges)
      }
    }

    // Ensure we have exactly 10 challenges
    while (newChallenges.length < 10) {
      const randomDifficulty = difficulties[Math.floor(Math.random() * difficulties.length)]
      const additionalChallenges = await fetchChallengesByDifficulty(randomDifficulty, 1)
      if (additionalChallenges.length > 0) {
        newChallenges.push(...additionalChallenges)
      }
    }
    
    // Trim to exactly 10 if we have more
    const dailyChallenges = newChallenges.slice(0, 10)

    // Combine with existing user-created challenges from database
    const userCreatedChallenges = dbResult?.filter(c => 
      !c.isAutoGenerated || c.dailyBatch !== today
    ) || []

    const allChallenges = [...dailyChallenges, ...userCreatedChallenges]

    // Save new auto-generated challenges to database
    if (dailyChallenges.length > 0) {
      console.log(`Saving ${dailyChallenges.length} new daily challenges to database`)
      const saveResult = await saveChallengesArrayToDatabase(dailyChallenges, true)
      if (!saveResult.success) {
        console.warn("Failed to save challenges to database:", saveResult.error)
      }
    }

    // Update the cache
    globalChallengeCache = {
      challenges: allChallenges,
      date: today,
      timestamp: Date.now(),
    }

    return allChallenges
  } catch (error) {
    console.error("Error fetching all challenges:", error)

    // Try to get challenges from database as fallback
    try {
      const dbResult = await getTodaysChallengesFromDatabase()
      if (dbResult && dbResult.length > 0) {
        console.log("Using database challenges as fallback")
        return dbResult
      }
    } catch (dbError) {
      console.error("Database fallback also failed:", dbError)
    }

    // If we have cached challenges (even from a previous day), use them as fallback
    if (globalChallengeCache.challenges.length > 0) {
      console.log("Using previously cached challenges as fallback")
      return globalChallengeCache.challenges
    }

    return []
  }
}

// Hàm lấy thử thách hiện tại cho người dùng
export async function fetchCurrentChallenge(): Promise<Challenge | null> {
  try {
    const today = getTodayDate()

    // Check if we have a cached current challenge for today
    if (currentChallengeCache.challenge && currentChallengeCache.date === today) {
      console.log("Using cached current challenge for today")
      return currentChallengeCache.challenge
    }

    // First, try to get today's challenges from database
    console.log("Checking database for today's current challenge")
    try {
      const dbResult = await getTodaysChallengesFromDatabase()
      if (dbResult && dbResult.length > 0) {
        // Use the first auto-generated challenge as current challenge
        const todayAutoGenerated = dbResult.filter(c => 
          c.isAutoGenerated && c.dailyBatch === today
        )
        
        if (todayAutoGenerated.length > 0) {
          const currentChallenge = todayAutoGenerated[0]
          console.log("Using existing auto-generated challenge as current challenge")
          
          // Update the cache
          currentChallengeCache = {
            challenge: currentChallenge,
            date: today,
          }
          
          return currentChallenge
        }
      }
    } catch (dbError) {
      console.error("Error getting challenges from database:", dbError)
    }

    console.log("Fetching new current challenge for today")

    // Lấy một video ngẫu nhiên từ các chủ đề chung
    const generalTopics = challengeTopics.general
    const randomTopic = generalTopics[Math.floor(Math.random() * generalTopics.length)]

    const videoData = await fetchRandomYoutubeVideo(180, 300, [randomTopic])
    const challenge = videoDataToChallenge(videoData, undefined, true)

    // Save current challenge to database
    try {
      const saveResult = await saveChallengeToDatabase(challenge)
      if (!saveResult.success) {
        console.warn("Failed to save current challenge to database:", saveResult.error)
      }
    } catch (saveError) {
      console.warn("Error saving current challenge to database:", saveError)
    }

    // Update the cache
    currentChallengeCache = {
      challenge,
      date: today,
    }

    return challenge
  } catch (error) {
    console.error("Error fetching current challenge:", error)

    // Try to get from database as fallback
    try {
      const dbResult = await getTodaysChallengesFromDatabase()
      if (dbResult && dbResult.length > 0) {
        const fallbackChallenge = dbResult[0]
        console.log("Using fallback video")
        currentChallengeCache = {
          challenge: fallbackChallenge,
          date: getTodayDate(),
        }
        return fallbackChallenge
      }
    } catch (dbError) {
      console.error("Database fallback failed:", dbError)
    }

    // If we have a cached challenge (even from a previous day), use it as fallback
    if (currentChallengeCache.challenge) {
      console.log("Using previously cached current challenge as fallback")
      return currentChallengeCache.challenge
    }

    return null
  }
}
