"use server"

import { fetchRandomYoutubeVideo, type VideoData } from "./youtube-video"
import { classifyChallengeDifficulty } from "@/utils/challenge-classifier"
import { challengeTopics, type Challenge } from '@/utils/challenge-constants'
import { supabaseServer } from "@/lib/supabase-server"
import type { Database } from "@/lib/database.types"

// Function to get today's date as a string (YYYY-MM-DD format)
const getTodayDate = () => {
  const today = new Date()
  return `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`
}



// H√†m chuy·ªÉn ƒë·ªïi VideoData th√†nh Challenge
function videoDataToChallenge(videoData: VideoData, forceDifficulty?: string): Challenge {
  const difficulty =
    forceDifficulty || classifyChallengeDifficulty(videoData.title, videoData.description, videoData.duration)

  const today = getTodayDate()
  
  return {
    id: videoData.id,
    title: videoData.title,
    description: videoData.description,
    thumbnailUrl: videoData.thumbnailUrl,
    videoUrl: videoData.videoUrl,
    embedUrl: videoData.embedUrl,
    duration: videoData.duration,
    difficulty,
    createdAt: new Date().toISOString(),
    topics: Array.isArray(videoData.topics) ? videoData.topics : [],
    featured: Math.random() < 0.2, // 20% chance to be featured
    isAutoGenerated: true,
    dailyBatch: today
  }
}

// H√†m l·∫•y video cho m·ªôt c·∫•p ƒë·ªô c·ª• th·ªÉ
export async function fetchChallengesByDifficulty(
  difficulty: "beginner" | "intermediate" | "advanced",
  count = 2,
): Promise<Challenge[]> {
  const challenges: Challenge[] = []
  const topics = challengeTopics[difficulty] || []

  // Thi·∫øt l·∫≠p th·ªùi l∆∞·ª£ng video d·ª±a tr√™n c·∫•p ƒë·ªô
  let minDuration = 60 // 2 ph√∫t
  let maxDuration = 2700 // 5 ph√∫t

  if (difficulty === "beginner") {
    minDuration = 120 // 2 ph√∫t
    maxDuration = 2700 // 4 ph√∫t
  } else if (difficulty === "intermediate") {
    minDuration = 180 // 3 ph√∫t
    maxDuration = 2700 // 5 ph√∫t
  } else if (difficulty === "advanced") {
    minDuration = 240 // 4 ph√∫t
    maxDuration = 2700 // 7 ph√∫t
  }

  // L·∫•y ng·∫´u nhi√™n c√°c ch·ªß ƒë·ªÅ t·ª´ danh s√°ch
  const shuffledTopics = [...(Array.isArray(topics) ? topics : [])].sort(() => 0.5 - Math.random())
  const selectedTopics = shuffledTopics.slice(0, count)

  // L·∫•y video cho m·ªói ch·ªß ƒë·ªÅ
  for (const topic of selectedTopics) {
    try {
      const videoData = await fetchRandomYoutubeVideo(minDuration, maxDuration, [topic])
      const challenge = videoDataToChallenge(videoData, difficulty)
      challenges.push(challenge)
    } catch (error) {
      console.error(`Error fetching video for topic ${topic}:`, error)
    }
  }

  return challenges
}

// New Supabase-only implementation for challenges
export async function fetchAllChallenges(): Promise<Challenge[]> {
  const today = getTodayDate()
  
  try {
    console.log(`üìä Fetching today's challenges from Supabase (${today})...`)
    
    // 1. Check Supabase for today's challenges
    const { data, error } = await supabaseServer
      .from('daily_challenges')
      .select('*')
      .eq('date', today)
      .order('created_at')
      
    if (data && !error && data.length > 0) {
      console.log(`‚úÖ Found ${data.length} challenges in Supabase for today`)      // Convert Supabase data to Challenge format
      return data.map(row => {
        const challenge = row as any // Type casting to bypass TypeScript issues temporarily
        return {
          id: challenge.id,
          title: challenge.title,
          description: challenge.description || "Educational challenge",
          thumbnailUrl: challenge.thumbnail_url || `https://img.youtube.com/vi/${challenge.id}/hqdefault.jpg`,
          videoUrl: challenge.video_url,
          embedUrl: challenge.embed_url || `https://www.youtube.com/embed/${challenge.id}`,
          duration: challenge.duration || 300,
          difficulty: challenge.difficulty,
          createdAt: challenge.created_at || new Date().toISOString(),
          topics: challenge.topics || [],
          featured: challenge.featured || false,
          isAutoGenerated: true,
          dailyBatch: today
        }
      })
    }
    
    console.log("‚ö†Ô∏è No challenges found in Supabase for today. Waiting for cron job to generate new challenges.")
    return []
    
  } catch (error) {
    console.error("‚ùå Error fetching challenges from Supabase:", error)
    return []
  }
}

// H√†m l·∫•y th·ª≠ th√°ch hi·ªán t·∫°i cho ng∆∞·ªùi d√πng (homepage)
export async function fetchCurrentChallenge(): Promise<Challenge | null> {
  try {
    const today = getTodayDate()
    
    console.log("üîç Checking Supabase for today's current challenge")
    
    // Get today's challenges from Supabase
    const challenges = await fetchAllChallenges()
    
    if (challenges.length > 0) {
      // Use the first challenge as current challenge
      const currentChallenge = challenges[0]
      console.log("‚úÖ Using first challenge as current challenge:", currentChallenge.id)
      return currentChallenge
    }

    console.log("‚ö†Ô∏è No current challenge found for today. Waiting for cron job to generate new challenges.")
    return null

  } catch (error) {
    console.error("‚ùå Error fetching current challenge:", error)
    return null
  }
}

// Generate 10 challenges for the day - OPTIMIZED VERSION
export async function generateDailyChallenges(): Promise<Challenge[]> {
  const today = getTodayDate()
  const challenges: Challenge[] = []
  const usedVideoIds = new Set<string>() // Track used video IDs to prevent duplicates
  
  try {
    console.log(`üöÄ Generating 10 challenges for ${today}...`)
    
    // Distribution: 3 beginner, 4 intermediate, 3 advanced
    const difficulties = [
      ...Array(3).fill('beginner'),
      ...Array(4).fill('intermediate'), 
      ...Array(3).fill('advanced')
    ]
    
    // Generate ALL challenges in parallel for maximum speed
    console.log(`‚ö° Generating all 10 challenges in parallel...`)
    
    const challengePromises = difficulties.map(async (difficulty, index) => {
      const difficultyType = difficulty as 'beginner' | 'intermediate' | 'advanced'
      
      try {
        console.log(`üìπ Starting ${difficultyType} challenge ${index + 1}/10...`)
        
        // Duration based on difficulty - reduced durations for faster generation
        let minDuration = 60, maxDuration = 600 // Max 10 minutes for faster processing
        if (difficultyType === 'beginner') {
          minDuration = 60  // 1 min
          maxDuration = 10000 // 4 min
        } else if (difficultyType === 'intermediate') {
          minDuration = 120 // 2 min  
          maxDuration = 20000 // 6 min
        } else {
          minDuration = 180 // 3 min
          maxDuration = 30000 // 10 min
        }
        
        // Only retry once to speed up generation
        let attempts = 0
        let videoData: VideoData | null = null
        
        while (attempts < 2 && !videoData) { // Reduced from 3 to 2 attempts
          attempts++
          try {
            const candidateVideo = await fetchRandomYoutubeVideo(
              minDuration,
              maxDuration,
              ["english", "education", "learning"] // Simplified search terms
            )
            
            // For parallel execution, we'll check duplicates later
            videoData = candidateVideo
            break
            
          } catch (error) {
            console.error(`‚ùå Attempt ${attempts} failed for ${difficultyType} challenge:`, error)
          }
        }
        
        if (!videoData) {
          console.error(`‚ùå Failed to get video for ${difficultyType} challenge after 2 attempts`)
          return null
        }
        
        const challenge = videoDataToChallenge(videoData, difficultyType)
        console.log(`‚úÖ Generated ${difficultyType} challenge: ${challenge.title} (${challenge.id})`)
        
        return challenge
        
      } catch (error) {
        console.error(`‚ùå Error generating ${difficultyType} challenge:`, error)
        return null
      }
    })
    
    // Wait for ALL challenges to complete in parallel
    console.log(`‚è≥ Waiting for all 10 challenges to complete...`)
    const allResults = await Promise.all(challengePromises)
    
    // Filter out nulls and handle duplicates
    const validChallenges = allResults.filter(Boolean) as Challenge[]
    
    // Remove duplicates based on video ID
    for (const challenge of validChallenges) {
      if (!usedVideoIds.has(challenge.id)) {
        usedVideoIds.add(challenge.id)
        challenges.push(challenge)
      } else {
        console.log(`üîÑ Skipping duplicate video: ${challenge.id}`)
      }
    }
    
    console.log(`üéØ Generated ${challenges.length} unique challenges out of ${validChallenges.length} total`)
    
    // If we have less than 10 unique challenges, add some fallback logic
    if (challenges.length < 10) {
      console.log(`‚ö†Ô∏è Only ${challenges.length} unique challenges generated, proceeding with what we have`)
    }
      // Save all challenges to Supabase
    if (challenges.length > 0) {
      console.log(`üíæ Saving ${challenges.length} challenges to Supabase...`)
      
      const challengeRows = challenges.map(challenge => ({
        id: challenge.id,
        title: challenge.title,
        description: challenge.description,
        video_url: challenge.videoUrl,
        thumbnail_url: challenge.thumbnailUrl,
        embed_url: challenge.embedUrl,
        duration: challenge.duration,
        topics: challenge.topics,
        difficulty: challenge.difficulty,
        featured: challenge.featured,
        date: today,
        created_at: new Date().toISOString()
      }))
      
      // Use upsert instead of insert to handle duplicates gracefully
      const { error } = await supabaseServer
        .from('daily_challenges')
        .upsert(challengeRows, { 
          onConflict: 'id',
          ignoreDuplicates: false 
        })
      
      if (error) {
        console.error("‚ùå Error saving challenges to Supabase:", error)
        throw error
      }
      
      console.log(`‚úÖ Successfully saved ${challenges.length} challenges to Supabase`)
    }
    
    return challenges
    
  } catch (error) {
    console.error("‚ùå Error generating daily challenges:", error)
    return challenges // Return whatever we managed to generate
  }
}
