/// <reference lib="webworker" />

import { clientsClaim } from "workbox-core";
import { ExpirationPlugin } from "workbox-expiration";
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from "workbox-strategies";

declare const self: ServiceWorkerGlobalScope;

// Custom types
interface CustomServiceWorkerGlobalScope extends ServiceWorkerGlobalScope {
  __WB_MANIFEST: any;
}

// Fix TypeScript reference to self
const selfAny = self as any;

// Claim clients immediately
clientsClaim();

// Precache all assets generated by your build process
const manifest = (self as CustomServiceWorkerGlobalScope).__WB_MANIFEST;
precacheAndRoute(manifest);

// Set up App Shell-style routing
const fileExtensionRegexp = /\/[^/?]+\.[^/]+$/;
registerRoute(({ request, url }) => {
  // If this is a navigation request, use the App Shell
  if (request.mode === "navigate") {
    return !url.pathname.startsWith("/_") && !url.pathname.match(fileExtensionRegexp);
  }
  return false;
}, createHandlerBoundToURL("/"));

// Cache page data and API responses
registerRoute(
  ({ url }) => url.origin === self.location.origin && url.pathname.startsWith("/api/"),
  new NetworkFirst({
    cacheName: "api-responses",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60, // 1 hour
      }),
    ],
  })
);

// Cache static assets
registerRoute(
  ({ request, url }) =>
    url.origin === self.location.origin &&
    (url.pathname.endsWith(".js") ||
      url.pathname.endsWith(".css") ||
      url.pathname.endsWith(".woff2") ||
      url.pathname.match(/\.(png|jpg|jpeg|svg|gif)$/)),
  new StaleWhileRevalidate({
    cacheName: "static-assets",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
      }),
    ],
  })
);

// Cache images
registerRoute(
  ({ request }) => request.destination === "image",
  new CacheFirst({
    cacheName: "images",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// Open database function
interface SubmissionData {
  id: string;
  [key: string]: any;
}

interface DBWithStore {
  getAll(storeName: string): Promise<SubmissionData[]>;
  delete(storeName: string, key: string): Promise<void>;
}

async function openDB(): Promise<DBWithStore> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open("EnglishLearningDB", 1);
    
    request.onupgradeneeded = (event) => {
      const db = request.result;
      if (!db.objectStoreNames.contains("pending-submissions")) {
        db.createObjectStore("pending-submissions", { keyPath: "id" });
      }
    };
    
    request.onsuccess = () => {
      const db = request.result;
      
      // Create a wrapper around the database with typed methods
      const dbWrapper: DBWithStore = {
        async getAll(storeName: string): Promise<SubmissionData[]> {
          return new Promise((resolve, reject) => {
            const transaction = db.transaction(storeName, "readonly");
            const store = transaction.objectStore(storeName);
            const getAllRequest = store.getAll();
            
            getAllRequest.onsuccess = () => resolve(getAllRequest.result);
            getAllRequest.onerror = () => reject(getAllRequest.error);
          });
        },
        
        async delete(storeName: string, key: string): Promise<void> {
          return new Promise((resolve, reject) => {
            const transaction = db.transaction(storeName, "readwrite");
            const store = transaction.objectStore(storeName);
            const deleteRequest = store.delete(key);
            
            deleteRequest.onsuccess = () => resolve();
            deleteRequest.onerror = () => reject(deleteRequest.error);
          });
        }
      };
      
      resolve(dbWrapper);
    };
    
    request.onerror = () => reject(request.error);
  });
}

// Add event listener for sync events
self.addEventListener("sync", (event) => {
  const syncEvent = event as Event & { tag: string, waitUntil(promise: Promise<any>): void };
  
  if (syncEvent.tag === "post-submission") {
    syncEvent.waitUntil(syncPostSubmissions());
  }
});

async function syncPostSubmissions() {
  try {
    const db = await openDB();
    const pendingSubmissions = await db.getAll("pending-submissions");

    for (const submission of pendingSubmissions) {
      try {
        const response = await fetch("/api/submissions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(submission),
        });

        if (response.ok) {
          await db.delete("pending-submissions", submission.id);
        }
      } catch (error) {
        console.error("Failed to sync submission:", error);
      }
    }
  } catch (error) {
    console.error("Error in syncPostSubmissions:", error);
  }
}

// Add event listener for push notifications
self.addEventListener("push", (event) => {
  const pushEvent = event as PushEvent;
  
  if (!pushEvent.data) return;
  
  const data = pushEvent.data.json();
  const { title, body, url } = data;
  
  const showNotification = self.registration.showNotification(title, {
    body,
    icon: "/favicon.ico",
    badge: "/notification-badge.png",
    data: { url },
  });
  
  pushEvent.waitUntil(showNotification);
});

// Handle notification clicks
self.addEventListener("notificationclick", (event) => {
  const notificationEvent = event as NotificationEvent;
  notificationEvent.notification.close();
  
  if (notificationEvent.notification.data && notificationEvent.notification.data.url) {
    const url = notificationEvent.notification.data.url;
    
    const promiseChain = self.clients.matchAll({ type: "window" }).then((clientList) => {
      for (const client of clientList) {
        if (client.url === url && "focus" in client) {
          return client.focus();
        }
      }
      
      if (self.clients.openWindow) {
        return self.clients.openWindow(url);
      }
    });
    
    notificationEvent.waitUntil(promiseChain);
  }
});

// Skip waiting on install
self.addEventListener("install", (event) => {
  self.skipWaiting();
});
