-- Migration to add new fields to challenges table for daily video management
-- Run this in Supabase SQL Editor

-- Add new columns to challenges table
ALTER TABLE challenges ADD COLUMN IF NOT EXISTS "expiresAt" TIMESTAMP WITH TIME ZONE;
ALTER TABLE challenges ADD COLUMN IF NOT EXISTS "isAutoGenerated" BOOLEAN DEFAULT false;
ALTER TABLE challenges ADD COLUMN IF NOT EXISTS "videoId" TEXT;
ALTER TABLE challenges ADD COLUMN IF NOT EXISTS "dailyBatch" TEXT;
ALTER TABLE challenges ADD COLUMN IF NOT EXISTS "isCompleted" BOOLEAN DEFAULT false;
ALTER TABLE challenges ADD COLUMN IF NOT EXISTS "completedAt" TIMESTAMP WITH TIME ZONE;

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS "idx_challenges_auto_generated" ON challenges("isAutoGenerated");
CREATE INDEX IF NOT EXISTS "idx_challenges_daily_batch" ON challenges("dailyBatch");
CREATE INDEX IF NOT EXISTS "idx_challenges_expires_at" ON challenges("expiresAt");
CREATE INDEX IF NOT EXISTS "idx_challenges_created_at" ON challenges("createdAt");

-- Update RLS policies to allow service role to manage auto-generated challenges
DROP POLICY IF EXISTS "Only admins and moderators can create challenges" ON challenges;
DROP POLICY IF EXISTS "Only admins and moderators can update challenges" ON challenges;
DROP POLICY IF EXISTS "Only admins can delete challenges" ON challenges;

-- New policies that allow service role for auto-generated challenges
CREATE POLICY "Service role can manage auto-generated challenges"
ON challenges FOR ALL
USING (
  -- Allow service role (used by server actions) to manage all challenges
  auth.role() = 'service_role'
  OR
  -- Allow admins and moderators to manage all challenges
  EXISTS (
    SELECT 1 FROM users 
    WHERE id = auth.uid()::text 
    AND role IN ('ADMIN', 'MODERATOR')
  )
  OR
  -- Allow authenticated users to create user-generated challenges
  (auth.role() = 'authenticated' AND "isAutoGenerated" = false)
);

-- Separate policy for reading challenges
CREATE POLICY "Anyone can view active public challenges"
ON challenges FOR SELECT
USING ("isActive" = true AND "isPublic" = true);

-- Function to automatically set expiration date for auto-generated challenges
CREATE OR REPLACE FUNCTION set_challenge_expiration()
RETURNS TRIGGER AS $$
BEGIN
  -- Set expiration to 30 days from creation for auto-generated challenges
  IF NEW."isAutoGenerated" = true AND NEW."expiresAt" IS NULL THEN
    NEW."expiresAt" = NEW."createdAt" + INTERVAL '30 days';
  END IF;
  
  -- Set daily batch for auto-generated challenges
  IF NEW."isAutoGenerated" = true AND NEW."dailyBatch" IS NULL THEN
    NEW."dailyBatch" = DATE(NEW."createdAt");
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to automatically set expiration
DROP TRIGGER IF EXISTS trigger_set_challenge_expiration ON challenges;
CREATE TRIGGER trigger_set_challenge_expiration
  BEFORE INSERT ON challenges
  FOR EACH ROW
  EXECUTE FUNCTION set_challenge_expiration();

-- Function to clean up expired challenges
CREATE OR REPLACE FUNCTION cleanup_expired_challenges()
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  -- Delete expired auto-generated challenges or completed challenges older than 30 days
  DELETE FROM challenges 
  WHERE "isAutoGenerated" = true 
  AND (
    ("expiresAt" IS NOT NULL AND "expiresAt" < NOW())
    OR 
    ("isCompleted" = true AND "completedAt" < NOW() - INTERVAL '30 days')
  );
  
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- Function to clean up old daily batches (keep only latest 10 per day)
CREATE OR REPLACE FUNCTION cleanup_old_daily_challenges()
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  -- For each daily batch, keep only the 10 most recent auto-generated challenges
  WITH ranked_challenges AS (
    SELECT id, 
           ROW_NUMBER() OVER (PARTITION BY "dailyBatch" ORDER BY "createdAt" DESC) as rn
    FROM challenges 
    WHERE "isAutoGenerated" = true
    AND "dailyBatch" IS NOT NULL
  )
  DELETE FROM challenges 
  WHERE id IN (
    SELECT id FROM ranked_challenges WHERE rn > 10
  );
  
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- Grant necessary permissions
GRANT USAGE ON SCHEMA public TO service_role;
GRANT ALL ON ALL TABLES IN SCHEMA public TO service_role;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO service_role;
